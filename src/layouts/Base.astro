---
import { ViewTransitions } from "astro:transitions";
import "../styles/global.css";
import Nav from "../components/Nav.astro";
import Footer from "../components/Footer.astro";
import Search from "../components/Search.astro";

interface Props {
  title: string;
  description?: string;
}

const { title, description = "Sam Duke — web developer, founder, builder on the edge." } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content={description} />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=block" />
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;700&display=block" rel="stylesheet" />
    <title>{title} — Sam Duke</title>
    <ViewTransitions />
  </head>
  <body>
    <div class="bg-grid" aria-hidden="true"></div>
    <canvas class="node-graph" id="node-graph" aria-hidden="true"></canvas>
    <Nav transition:persist />
    <main>
      <slot />
    </main>
    <Footer />
    <Search />
  </body>
</html>

<style>
  .bg-grid {
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(var(--color-grid-line) 1px, transparent 1px),
      linear-gradient(90deg, var(--color-grid-line) 1px, transparent 1px);
    background-size: 60px 60px;
    opacity: 0.2;
    pointer-events: none;
    z-index: 0;
  }

  .node-graph {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
  }

  body {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  body > :not(.bg-grid):not(.node-graph) {
    position: relative;
    z-index: 1;
  }

  main {
    flex: 1;
  }

  /* Disable stagger animations during view transition navigations */
  body.vt-nav :global(.animate-fade-in-up) {
    animation: none !important;
    opacity: 1 !important;
    transform: none !important;
  }
</style>

<script>
  // On view transition navigations, skip the stagger animations
  document.addEventListener("astro:after-swap", () => {
    document.body.classList.add("vt-nav");
  });

  // ── Animated Node Graph Background ──
  function initNodeGraph() {
    const canvas = document.getElementById("node-graph") as HTMLCanvasElement;
    if (!canvas) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const NODE_COUNT = 60;
    const CONNECT_DIST = 150;
    const NODE_COLOR = "rgba(59, 130, 246, 0.35)";
    const LINE_COLOR_BASE = [59, 130, 246];
    const NODE_RADIUS = 1.5;

    interface Node {
      x: number;
      y: number;
      vx: number;
      vy: number;
    }

    let nodes: Node[] = [];
    let w = 0;
    let h = 0;
    let animId = 0;

    function resize() {
      const dpr = window.devicePixelRatio || 1;
      w = window.innerWidth;
      h = window.innerHeight;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      ctx!.scale(dpr, dpr);
    }

    function createNodes() {
      nodes = [];
      for (let i = 0; i < NODE_COUNT; i++) {
        nodes.push({
          x: Math.random() * w,
          y: Math.random() * h,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
        });
      }
    }

    function draw() {
      ctx!.clearRect(0, 0, w, h);

      // Draw connections
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[i].x - nodes[j].x;
          const dy = nodes[i].y - nodes[j].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < CONNECT_DIST) {
            const alpha = (1 - dist / CONNECT_DIST) * 0.12;
            ctx!.strokeStyle = `rgba(${LINE_COLOR_BASE[0]},${LINE_COLOR_BASE[1]},${LINE_COLOR_BASE[2]},${alpha})`;
            ctx!.lineWidth = 1;
            ctx!.beginPath();
            ctx!.moveTo(nodes[i].x, nodes[i].y);
            ctx!.lineTo(nodes[j].x, nodes[j].y);
            ctx!.stroke();
          }
        }
      }

      // Draw nodes
      ctx!.fillStyle = NODE_COLOR;
      for (const node of nodes) {
        ctx!.beginPath();
        ctx!.arc(node.x, node.y, NODE_RADIUS, 0, Math.PI * 2);
        ctx!.fill();
      }
    }

    function update() {
      for (const node of nodes) {
        node.x += node.vx;
        node.y += node.vy;

        if (node.x < 0 || node.x > w) node.vx *= -1;
        if (node.y < 0 || node.y > h) node.vy *= -1;
      }
    }

    function loop() {
      update();
      draw();
      animId = requestAnimationFrame(loop);
    }

    // Cleanup previous instance if any
    cancelAnimationFrame(animId);
    resize();
    createNodes();
    loop();

    window.addEventListener("resize", () => {
      resize();
    });
  }

  // Run on initial load
  initNodeGraph();

  // Re-init after view transition swaps
  document.addEventListener("astro:after-swap", () => {
    initNodeGraph();
  });
</script>
