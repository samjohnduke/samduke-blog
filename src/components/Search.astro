---

---

<!-- Search modal overlay -->
<div class="search-overlay" id="search-overlay" aria-hidden="true">
  <div class="search-modal" role="dialog" aria-label="Search">
    <div class="search-header">
      <svg class="search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"/>
        <line x1="21" y1="21" x2="16.65" y2="16.65"/>
      </svg>
      <input
        type="text"
        class="search-input"
        id="search-input"
        placeholder="search posts, projects, notes..."
        autocomplete="off"
        spellcheck="false"
      />
      <kbd class="search-esc">esc</kbd>
    </div>
    <div class="search-results" id="search-results">
      <div class="search-empty" id="search-empty">
        <p class="search-empty-text">type to search across all content</p>
      </div>
    </div>
  </div>
</div>

<style>
  .search-overlay {
    position: fixed;
    inset: 0;
    z-index: 200;
    background: rgba(44, 36, 24, 0.15);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: flex-start;
    justify-content: center;
    padding-top: min(20vh, 140px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s ease;
  }

  .search-overlay.open {
    opacity: 1;
    pointer-events: auto;
  }

  .search-modal {
    width: 100%;
    max-width: 560px;
    margin: 0 1rem;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 6px;
    box-shadow: 0 16px 48px rgba(44, 36, 24, 0.12);
    overflow: hidden;
    transform: translateY(-8px);
    transition: transform 0.15s ease;
  }

  .search-overlay.open .search-modal {
    transform: translateY(0);
  }

  .search-header {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.875rem 1rem;
    border-bottom: 1px solid var(--color-border);
  }

  .search-icon {
    flex-shrink: 0;
    color: var(--color-text-muted);
  }

  .search-input {
    flex: 1;
    background: none;
    border: none;
    outline: none;
    font-family: var(--font-body);
    font-size: 0.95rem;
    color: var(--color-text);
  }

  .search-input::placeholder {
    color: var(--color-text-muted);
  }

  .search-esc {
    font-family: var(--font-mono);
    font-size: 0.6rem;
    padding: 2px 6px;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 3px;
    color: var(--color-text-muted);
    flex-shrink: 0;
  }

  .search-results {
    max-height: 400px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--color-border-bright) var(--color-surface);
  }

  .search-empty {
    padding: 2rem 1rem;
    text-align: center;
  }

  .search-empty-text {
    font-family: var(--font-body);
    font-size: 0.85rem;
    color: var(--color-text-muted);
    margin: 0;
    font-style: italic;
  }

  /* Result items (injected via JS) */
  .search-results :global(.search-result) {
    display: flex;
    align-items: flex-start;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    text-decoration: none;
    color: inherit;
    border-bottom: 1px solid var(--color-border);
    transition: background 0.15s ease;
    cursor: pointer;
  }

  .search-results :global(.search-result:last-child) {
    border-bottom: none;
  }

  .search-results :global(.search-result:hover),
  .search-results :global(.search-result.active) {
    background: var(--color-surface-hover);
  }

  .search-results :global(.result-type) {
    font-family: var(--font-mono);
    font-size: 0.58rem;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 0.2em 0.5em;
    border-radius: 3px;
    flex-shrink: 0;
    margin-top: 0.15rem;
  }

  .search-results :global(.result-type.blog) {
    background: var(--color-accent-glow);
    color: var(--color-accent);
  }

  .search-results :global(.result-type.project) {
    background: var(--color-indigo-dim);
    color: var(--color-indigo);
  }

  .search-results :global(.result-type.note) {
    background: rgba(160, 149, 133, 0.1);
    color: var(--color-text-secondary);
  }

  .search-results :global(.result-body) {
    min-width: 0;
  }

  .search-results :global(.result-title) {
    font-family: var(--font-display);
    font-size: 0.95rem;
    font-weight: 600;
    color: var(--color-text);
    margin: 0 0 0.15rem;
  }

  .search-results :global(.result-title mark) {
    background: none;
    color: var(--color-accent);
    text-decoration: underline;
    text-underline-offset: 2px;
  }

  .search-results :global(.result-desc) {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .search-results :global(.result-desc mark) {
    background: none;
    color: var(--color-text-secondary);
  }

  .search-results :global(.search-no-results) {
    padding: 2rem 1rem;
    text-align: center;
    font-family: var(--font-body);
    font-size: 0.85rem;
    color: var(--color-text-muted);
    font-style: italic;
  }
</style>

<script>
  import Fuse from "fuse.js";

  interface SearchItem {
    type: "blog" | "note" | "project";
    title: string;
    description: string;
    tags: string[];
    slug: string;
    date: string;
    body: string;
  }

  let fuse: Fuse<SearchItem> | null = null;
  let activeIndex = -1;

  function getEls() {
    return {
      overlay: document.getElementById("search-overlay")!,
      input: document.getElementById("search-input") as HTMLInputElement,
      results: document.getElementById("search-results")!,
      empty: document.getElementById("search-empty")!,
    };
  }

  async function loadIndex() {
    if (fuse) return;
    const res = await fetch("/search-index.json");
    const searchIndex: SearchItem[] = await res.json();
    fuse = new Fuse(searchIndex, {
      keys: [
        { name: "title", weight: 3 },
        { name: "description", weight: 2 },
        { name: "tags", weight: 1.5 },
        { name: "body", weight: 0.5 },
      ],
      threshold: 0.35,
      includeMatches: true,
      minMatchCharLength: 2,
    });
  }

  function open() {
    const { overlay, input } = getEls();
    overlay.classList.add("open");
    overlay.setAttribute("aria-hidden", "false");
    input.focus();
    loadIndex();
    activeIndex = -1;
  }

  function close() {
    const { overlay, input, results, empty } = getEls();
    overlay.classList.remove("open");
    overlay.setAttribute("aria-hidden", "true");
    input.value = "";
    results.textContent = "";
    results.appendChild(empty);
    empty.style.display = "";
    activeIndex = -1;
  }

  function escapeHtml(str: string): string {
    return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }

  function highlightMatch(text: string, indices: readonly [number, number][] | undefined): string {
    if (!indices || indices.length === 0) return escapeHtml(text);
    const chars = [...text];
    const highlighted = new Set<number>();
    for (const [start, end] of indices) {
      for (let i = start; i <= end; i++) highlighted.add(i);
    }
    let result = "";
    let inMark = false;
    for (let i = 0; i < chars.length; i++) {
      if (highlighted.has(i) && !inMark) {
        result += "<mark>";
        inMark = true;
      } else if (!highlighted.has(i) && inMark) {
        result += "</mark>";
        inMark = false;
      }
      result += escapeHtml(chars[i]);
    }
    if (inMark) result += "</mark>";
    return result;
  }

  function renderResult(item: SearchItem, titleHtml: string, descHtml: string): HTMLAnchorElement {
    const a = document.createElement("a");
    a.href = item.slug;
    a.className = "search-result";

    const typeSpan = document.createElement("span");
    typeSpan.className = `result-type ${item.type}`;
    typeSpan.textContent = item.type;

    const bodyDiv = document.createElement("div");
    bodyDiv.className = "result-body";

    const titleP = document.createElement("p");
    titleP.className = "result-title";
    // titleHtml is built from escapeHtml'd content + safe <mark> tags
    titleP.innerHTML = titleHtml;

    bodyDiv.appendChild(titleP);

    if (descHtml) {
      const descP = document.createElement("p");
      descP.className = "result-desc";
      descP.innerHTML = descHtml;
      bodyDiv.appendChild(descP);
    }

    a.appendChild(typeSpan);
    a.appendChild(bodyDiv);
    return a;
  }

  function search(query: string) {
    const { results, empty } = getEls();

    if (!fuse || query.length < 2) {
      results.textContent = "";
      results.appendChild(empty);
      empty.style.display = "";
      empty.querySelector(".search-empty-text")!.textContent = "type to search across all content";
      activeIndex = -1;
      return;
    }

    const hits = fuse.search(query, { limit: 10 });
    activeIndex = -1;

    if (hits.length === 0) {
      results.textContent = "";
      const noResults = document.createElement("div");
      noResults.className = "search-no-results";
      noResults.textContent = `no results for "${query}"`;
      results.appendChild(noResults);
      return;
    }

    results.textContent = "";
    for (const hit of hits) {
      const item = hit.item;
      const titleMatch = hit.matches?.find((m) => m.key === "title");
      const descMatch = hit.matches?.find((m) => m.key === "description");

      const titleHtml = highlightMatch(item.title, titleMatch?.indices);
      const descHtml = item.description
        ? highlightMatch(
            item.description.slice(0, 100),
            descMatch?.indices?.map(([s, e]) => [s, Math.min(e, 99)] as [number, number])
          )
        : "";

      results.appendChild(renderResult(item, titleHtml, descHtml));
    }
  }

  function setActive(index: number) {
    const { results } = getEls();
    const items = results.querySelectorAll(".search-result");
    items.forEach((el) => el.classList.remove("active"));
    if (index >= 0 && index < items.length) {
      items[index].classList.add("active");
      items[index].scrollIntoView({ block: "nearest" });
    }
    activeIndex = index;
  }

  document.addEventListener("keydown", (e) => {
    const overlay = document.getElementById("search-overlay");
    if (!overlay) return;

    if ((e.metaKey || e.ctrlKey) && e.key === "k") {
      e.preventDefault();
      overlay.classList.contains("open") ? close() : open();
    }
    if (e.key === "Escape" && overlay.classList.contains("open")) {
      close();
    }

    if (!overlay.classList.contains("open")) return;

    const items = document.querySelectorAll("#search-results .search-result");
    if (e.key === "ArrowDown") {
      e.preventDefault();
      setActive(Math.min(activeIndex + 1, items.length - 1));
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      setActive(Math.max(activeIndex - 1, 0));
    } else if (e.key === "Enter" && activeIndex >= 0) {
      e.preventDefault();
      const active = items[activeIndex] as HTMLAnchorElement;
      if (active) {
        close();
        window.location.href = active.href;
      }
    }
  });

  document.addEventListener("click", (e) => {
    const trigger = (e.target as HTMLElement).closest("#search-trigger-nav");
    if (trigger) {
      e.preventDefault();
      open();
      return;
    }

    const overlay = document.getElementById("search-overlay");
    if (overlay?.classList.contains("open") && e.target === overlay) {
      close();
    }
  });

  document.getElementById("search-input")?.addEventListener("input", () => {
    const input = document.getElementById("search-input") as HTMLInputElement;
    search(input.value.trim());
  });
</script>
